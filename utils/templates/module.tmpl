package {{.PackageName}}

import (
    "{{.ModuleName}}/app/models"
    "{{.ModuleName}}/core/app/authorization"
    "{{.ModuleName}}/core/module"
    "{{.ModuleName}}/core/logger"
    "{{.ModuleName}}/core/router"
    "{{.ModuleName}}/core/storage"
    "{{.ModuleName}}/core/emitter"{{if .HasTranslatableFields}}
    "{{.ModuleName}}/core/translation"{{end}}
    "errors"

    "gorm.io/gorm"
)

type Module struct {
    module.DefaultModule
    DB         *gorm.DB
    Service    *{{.Service}}
    Controller *{{.Controller}}{{if .HasTranslatableFields}}
    TranslationHelper *translation.Helper{{end}}
}

// Init creates and initializes the {{.Model}} module with all dependencies
func Init(deps module.Dependencies) module.Module {
    {{if .HasTranslatableFields}}// Create translation service and helper
    translationService := translation.NewTranslationService(deps.DB, deps.Emitter, deps.Storage, deps.Logger)
    translationHelper := translation.NewHelper(translationService)
    
    // Initialize service with translation helper
    service := New{{.Service}}(deps.DB, deps.Emitter, deps.Storage, deps.Logger, translationHelper){{else}}// Initialize service and controller
    service := New{{.Service}}(deps.DB, deps.Emitter, deps.Storage, deps.Logger){{end}}
    controller := New{{.Controller}}(service, deps.Storage)
    
    // Create module
    mod := &Module{
        DB:         deps.DB,
        Service:    service,
        Controller: controller,{{if .HasTranslatableFields}}
        TranslationHelper: translationHelper,{{end}}
    }
    
    return mod
}

// Routes registers the module routes
func (m *Module) Routes(router *router.RouterGroup) {
    m.Controller.Routes(router)
}

func (m *Module) Init() error {
    // Auto-migrate the model
    if err := m.Migrate(); err != nil {
        return err
    }

    return m.SeedPermissions()
}

func (m *Module) SeedPermissions() error {
    // Ensure permissions table exists before seeding
    if err := m.DB.AutoMigrate(&authorization.Permission{}); err != nil {
        return err
    }

    // Define permissions for {{.ModelSnake}} CRUD operations
    {{.ModelSnake}}Permissions := []authorization.Permission{
        {
            Name:         "{{.ModelSnake}} list",
            Description:  "View {{.ModelSnake}} list",
            ResourceType: "{{.ModelSnake}}",
            Action:       "list",
        },
        {
            Name:         "{{.ModelSnake}} read",
            Description:  "View {{.ModelSnake}} details",
            ResourceType: "{{.ModelSnake}}",
            Action:       "read",
        },
        {
            Name:         "{{.ModelSnake}} create",
            Description:  "Create new {{.PluralSnake}}",
            ResourceType: "{{.ModelSnake}}",
            Action:       "create",
        },
        {
            Name:         "{{.ModelSnake}} update",
            Description:  "Update {{.ModelSnake}} information",
            ResourceType: "{{.ModelSnake}}",
            Action:       "update",
        },
        {
            Name:         "{{.ModelSnake}} delete",
            Description:  "Delete {{.PluralSnake}}",
            ResourceType: "{{.ModelSnake}}",
            Action:       "delete",
        },
    }

    // Track created/updated permission IDs for superadmin assignment
    var permissionIDs []uint

    // Upsert permissions - create or update if they exist
    for _, permission := range {{.ModelSnake}}Permissions {
        var existingPermission authorization.Permission
        result := m.DB.Where("resource_type = ? AND action = ?", permission.ResourceType, permission.Action).First(&existingPermission)

        if result.Error != nil && errors.Is(result.Error, gorm.ErrRecordNotFound) {
            // Create new permission
            if err := m.DB.Create(&permission).Error; err != nil {
                return err
            }
            permissionIDs = append(permissionIDs, permission.Id)
        } else if result.Error == nil {
            // Update existing permission
            existingPermission.Name = permission.Name
            existingPermission.Description = permission.Description
            if err := m.DB.Save(&existingPermission).Error; err != nil {
                return err
            }
            permissionIDs = append(permissionIDs, existingPermission.Id)
        } else {
            // Return any other error
            return result.Error
        }
    }

    // Assign all permissions to superadmin role (ID: 1)
    var superadminRole authorization.Role
    if err := m.DB.First(&superadminRole, 1).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            // Superadmin role doesn't exist yet, skip assignment
            return nil
        }
        return err
    }

    // Get existing permission IDs for superadmin
    var existingPermissions []authorization.Permission
    if err := m.DB.Model(&superadminRole).Association("Permissions").Find(&existingPermissions); err != nil {
        return err
    }

    existingPermissionMap := make(map[uint]bool)
    for _, perm := range existingPermissions {
        existingPermissionMap[perm.Id] = true
    }

    // Add only new permissions to superadmin
    var newPermissions []authorization.Permission
    for _, permID := range permissionIDs {
        if !existingPermissionMap[permID] {
            var perm authorization.Permission
            if err := m.DB.First(&perm, permID).Error; err != nil {
                return err
            }
            newPermissions = append(newPermissions, perm)
        }
    }

    // Append new permissions to superadmin role
    if len(newPermissions) > 0 {
        if err := m.DB.Model(&superadminRole).Association("Permissions").Append(newPermissions); err != nil {
            return err
        }
    }

    return nil
}

func (m *Module) Migrate() error {
    return m.DB.AutoMigrate(&models.{{.Model}}{}{{range .Fields}}{{if or (eq .Relationship "many_to_many") (eq .Relationship "manyToMany") (eq .Relationship "toMany") (eq .Relationship "to_many") (eq .Type "to_many") }}, &models.{{$.Model}}{{.RelatedModel}}{}{{end}}{{end}})
}

func (m *Module) GetModels() []any {
    return []any{
        &models.{{.Model}}{},{{range .Fields}}{{if or (eq .Relationship "many_to_many") (eq .Relationship "manyToMany") (eq .Relationship "toMany") (eq .Relationship "to_many") (eq .Type "to_many")}}
        &models.{{$.Model}}{{.RelatedModel}}{},{{end}}{{end}}
    }
}